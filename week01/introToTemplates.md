## Днес ще бистрим тънките подробности относно вече загатнатата тема за шаблоните.

# Какво е шаблон?
---------------

### Функция или клас, която работи не с променливи от някакъв дефиниран тип, а с абстрактни променливи, се нарича шаблонна функция/клас. Когато някоя програма използва такава функция, тя трябва да изрично да уточни с какъв тип данни се използва. Един много прост пример - фунцкия, която намира по-голямата от две променливи.

```
#include<iostream>
using std::cout;
using std::endl;

template <class T>
T max(T a, T b)
{
    return (a > b ? a : b);
}

int main()
{
    cout<<max(3,6)<<" "<<max("Tri","Shest");
    return 0;
}
```

# За какво са нужни?
------------------

### Има един вечен проблем в програмирането.

## Как да работим по-малко?

<h3>Как да си свършваме работата с по-малко код? Същите задачи, но за по-малко време?\
Всички умни хора са мързеливи - ако не бяха, щяха да си вършат работата по трудния начин. Някои програмисти са умни. Умните програмисти са мързеливи. Най-най-основният начин да пишем по-малко код и да гледаме повече смешни снимки на котки е да спазваме DRY принципа.\
**D**on't **R**epeat **Y**ourself. <br>
Ако пишеш един и същи алгоритъм два пъти, единият път е било загуба на време.\
Винаги е по-хубаво, когато софтуерът не се повтаря. Това контрастира с хардуера, при който колкото повече - толкова повече. Така де, ако имаш два трактора, това е по-хубаво, отколкото ако имаш един трактор. Ама нямаш особена нужда от два учебника по Дискретна Математика, нали?^1^</h3>
<br><br>

# Шаблоните са начинът, по който C++ се справя с проблема с повтарянето.
<h3>
Горният код реализира алгоритъма за намиране на максимален измежду два елемента за всички съществуващи типове данни. За цели числа, нецели числа, цели неотрицателни числа, символи, низове, указатели. И каквото още има в C++. Но наистина удобното му е, че това ще важи и за всеки тип, който някога може да бъде написан. Точно така, ако утре си направиш клас желе и искаш да видиш кое е по-вкусно - малиново желе или желе от диня - ще можеш да го направиш, без никакъв проблем.<h3>

# Каква е уловката?
<h3>
Всичката магия става в компилатора. Той вижда как точно се използва шаблона - именно с кои типове ще се използва, и генерира (и компилира) код за всеки един отделен тип.
Ако искаш следният код да се изпълни:

````
Jelly Pink("Raspberry");
Jelly Green("Watermelon");
cout<<max(Pink, Green)<<endl;
````

То, трябва да е сигурно, че това ще се компилира:
````
Jelly max(Jelly a, Jelly b)
{
    return (a > b ? a : b);
}
````
Защото компилаторът точно до това ще сведе кода на програмата. В крайна сметка, класът Jelly трябва да има дефиниран опреатор >. Логично. Това може би е очевидно, но същата логика важи за всички шаблони и всяка употреба на класовете:

````
template <class T>
int get_x(T item)
{
    return T.x;
}