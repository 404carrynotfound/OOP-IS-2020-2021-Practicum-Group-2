# Седмица 01

# Паметта, която можете да използвате в C++ програма е най-общо казано три типа:


## статична
   *в тази памет се записват променливите, обявени извън функциите
(т.нар. глобални променливи). Те се виждат от всички функции през
цялото изпълнение на програмата
## стекова
   * в тази памет се записван предадените параметри и променливите
дефинирани вътре във функциите и въобще в произволен блок.
Променливите се виждат само във функцията (блока) в която са
дефинирани и се унищожават при завършване на функцията (излизане
от блока)
## динамична
  * останалата част от паметта на компютърна е достъпна до всички
програми при поискване. За управлението на тази памет се грижи
операционната система. Във всеки момент отделен блок от паметта
може да е свободен или да е заделен за някоя програма, при която
може да го чете само тя. При опит някоя програма да прочете памет,
която не е заделена за нея, независимо дали е заделена за друга
програма или е свободна, операционната система прекратява
изпълнението на програмат с грешка Access Violation
  * в C++ програма можете да заделите памет за една променлива или за
масив от променливи с помощта на оператора new, който връща
указател към променливата:
* int* oneVariable = new int;
* int* array = new int[x];
* за разлика от статичната памет, в динамичната памет може да се
създават масиви, чиято големина не е известна предварително, т.е. е
пресметната или е прочетена от клавиатурата например.
* Променливите в динамичната памет се виждат през указателя, който
получавате от new до края на изпълнението на програмата, когато тази
памет се освобождава
* Заделена с new памет се освобождава с оператора delete
* delete oneVariable;
* delete[] array;
* С new се използва delete, а с new[...] се използва delete[]. Двете форми
не бива да се смесват
* Ако се опитате да използвате динамична памет след като сте я
освободили с delete - Access Violation
* Ако се опитате да освободите памет, която не сте заделили - Access
Violation


* Ако се опитате да освободите паметта, която сте заделили, но не от
началото (напр. delete array + 3) - Access Violation
* Ако забравите да освободите заделена памет или "загубите" указателя
към заделена памет, то тази памет става неизползваема за целия
компютър до завършването на програмата ви. Дори да губите само 1B
памет, ако това се случва например в два вложени цикъла от 1 до
50000, то цялата ви налична памет ще се изчерпи. Такава грешка се
нарича _memory leak_.
* Многомерни матрици не могат да се заделят с new, само едномерни
масиви
* Въпрос: как трябва да заделим данните, ако искаме да можем да ги
достъпваме с двойно индексиране, т.е. с a[i][j]? А как трябва да ги
освободим?
* Отговор: трябва a да е double** и освен това да създадем
допълнителен масив от указатели, които сочат към съответните
редове на матрицата


## Седмица 12

### Структури
Mасивитe ни позволяваха да съхраняваме елементи от един и същи тип в последователна наредба. Например масив от цели числа, символи и тн. В реалния живот се налага да работим с елементи от различни типове. Тогава се намесват структурите. Структурите са типове данни дефинирани от потребителя, които ни позволяват да групираме елементи от различни типове и да ги съхраняваме.

```c++
struct <name>
{
  <member definition>;  //  int arr[5];
  <member definition>;  //  int age;
  <member definition>;  //  double weight; 
        ...
  <member definition>;
  
}<one or more variables of <name> type>;

/*---------- Example ----------*/

struct Student
{
  char name[20];
  char faculty_number[5];
  unsigned int age;

};

```

### Дефиниране на променливи от тип структура
За структурата в паметта не се отделя памет. Паметта се отделя чак когато създадем обект от тип структура. Както при обикновените типове и тук дефинирането на променливи и константи от даден потребителски тип(структура) става чрез името на типа и името на променливата след това.

```c++
<name> <variable_name>;

/*---------- Example ----------*/

Student student_one;

```

### Достъп до елементите(членовете) на структурата
Достъпът до, който и да е, елемент на структурата се осъществява чрез оператора(.). Като използваме следния синтаксис:

```c++
<name>.<member_name>;

/*---------- Example ----------*/

cout << student_one.name << endl;
```

### Функции със структури
За структурите е характерно, че променливите от тип структура могат да се инициализират със стойности на вече дефинирана променлива от същия тип. 

```c++

Student student_one;
Student student_two = student_two;

```
Но за да работим със структурите ефективно трябва да дефинираме и други функции, като например функция:
* за инициализиране на елементите на структурата
* за извеждане на елементите на структурата на екрана
* за променяне стойностите на елементите на структурата

<br>

## <a href = "https://en.wikipedia.org/wiki/Data_structure_alignment?fbclid=IwAR0Vjz-hzTXGnP8-cDIAOhWutSGu7xYLF1OnojYAip4mY-pK8GYZ3SYLKeA" target = "_blank"> Допълнително четиво за структури 1</a>

## <a href = "https://www.geeksforgeeks.org/data-structure-alignment/?fbclid=IwAR0m3INKWr6ygvoFIau5UjxhFte93-PYY4MZ8cPWPxUE0u0ndlQ4ZQvpFbI" target = "_blank">Допълнително четиво за структури 2 </a>
