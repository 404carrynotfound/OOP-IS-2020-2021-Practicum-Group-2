# Седмица 8 - Практикум

<h3>
Трите основни принципа на обектно-ориентираното програмиране са капсулиране, наследяване и полиморфизъм. Те са налице във всички съвременни ОО езици и ще бъдат предмет на изучаване и в други курсове. С това съображение тук разглеждаме илюстративно особеностите на наследяването и полиморфизма в езика С++. Множественото наследяване в С++ умишлено не се разглежда, доколкото е специфика на езика, която не се поддържа в по-новите ОО езици.
<br>



## Наследяване в обектно-ориентираното програмиране
<h3>
Повторното използване на програмен код е важно за намаляване на разходите при производството на програмни продукти. Има се предвид повторното използване (без изменение) на готови програмни единици. Основният похват, използван за защита от изменения на готов и тестван програмен код е скриване на имплементацията. Класовете в обектно-ориентираното програмиране предоставят разнообразни възможности за контрол над достъпа на потребителите до функционалността на готови програмни единици. Тези възможности варират от пълна защита срещу изменения на готов клас (т.е. използването му само като готов тип) до пълна свобода за изменения и допълнения на функционалността на предоставения клас.  При това, без да се предоставя на клиента достъп до source кода. 
</h3>
<br>
<h3>
За използване на готов клас като нов тип данни е достатъчно компилаторът да разполага с декларацията на класа и обектният код с член-функциите на класа да е включен в проекта. От така представения нов тип може неограничено да се декларират и използват променливи (обекти) във всеки обхват, включително и като член-данни на ново-дефинирани класове. 
Включването на обекти от различни класове като член-данни на нов клас представлява агрегиране на класове. Агрегирането (наричано още композиция) изразява отношението „цяло-част” – обект от новия клас се състои от обекти от други класове. 
Обектите-членове са съставни части на обекта от новия клас. Член-функциите на новия клас могат да ползват съставните части само през техния интерфейс, т.е. като достъп до публичните им членове чрез името на съответната променлива. 
Такова използване (през членове-обекти) усложнява кода и влошава ефективността на изпълнението. В повечето случаи се желае директен достъп до членовете на готов клас и същевременно добавяне на нова функционалност или промяна на съществуващата. 
</h3>
<br>
<h3>
Наследяването е механизъм, който осигурява именно такава възможност. При наследяване изходният клас, наречен “базов” се включва изцяло в ново-дефинирания “производен” клас . 
От концептуална гледна точка (при моделиране на реалността) може да се мисли за следната ситуация: класът описва общите свойства на обектите, но отделни групи обекти може да имат допълнително още свойства, с което класът да се подразделя на “подкласове”. Отношението на подкласовете към класа може да се изрази с думите „ са вариант на...”. 
Обратно, ако група класове имат общи свойства, уместно е описанието на тези свойства да се обособи в отделен клас (супер-клас), варианти на който да са отделните класове с техните специфични особености. 
</h3>
<br>
<h3>
Създаването на обекти от производен клас е двустепенно: създаване на данните от базовия клас, после добавяне на собствените данни и функции. С тази цел конструкторът на производния клас задължително извиква конструктора на базовия. Ако в дефиницията на конструктора на производния клас такова извикване не е налице, компилаторът автоматично вмъква извикване на подразбиращия се конструктор на базовия клас. Деструктурирането на обекти от производен клас също е двустепенно, като се изпълнява в ред, обратен на конструирането – първо се извиква деструкторът на наследяващия клас, който затваря добавената от наследяването част от обекта, после автоматично се извиква деструкторът на базовия клас.
Самото наследяване може да бъде многостепенно – от производния клас също може да се наследява неограничен брой пъти. 
</h3>


## Деклариране на наследяване, достъп до наследената част на обекта
<h3>
При наследяване производният клас няма достъп до частните (private) членове на базовия клас. С това се ограничават възможностите за предефиниране на свойства при декларацията на производен клас. Ако се желае производният клас да има достъп до частните членове на базовия клас, те следва да бъдат декларирани в базовия клас като protected (защитен), а не като private. Описаните като protected членове на клас са достъпни за собствените член-функции и за член-функциите на производни класове. 
Фактът, че даден клас наследява (т.е. включва изцяло) друг съществуващ се изразява със следния синтаксис при декларация на производен клас:
</h3>

```C++
class име_производен_клас:
 	спецификатор_за_достъп име_базов_клас1,
 	спецификатор_за_достъп име_базов_клас2… 
{
членове_на_производния_клас 
};
```
<h3>
В  С++ може да се наследява повече от един клас. Базовите класове са описани в списъка, поместен между знаците ‘:’ и ‘{‘. Техните членове се “монтират” в тялото на производния клас в същия ред, т.е. при създаване на обект от производен клас конструкторите на базовите класове (ако са повече от един) се извикват в реда, описан в тази декларация.
</h3>
<br>
<h3>
Спецификаторите за достъп пред имената на базовите класове предефинират достъпа до членовете им за ползвателите и наследниците на производния клас. 
Спецификаторът public в случая означава, че членовете на базовия клас,  декларирани в него като public и protected остават със същия достъп и като членове на производния клас. 
Спецификаторът protected предефинира достъпа public на членовете на базовия клас: като членове на производния клас те ще бъдат protected. 
</h3>
<br>
<h3>
При изпускане на спецификатора се подразбира private, с което се закрива достъпът до членовете на базовия клас – те остават достъпни само за функциите на производния клас, но не и за негови ползуватели и наследници. Обичайна практика е базовият клас да се оставя public, с което цялата му функционалност може да се ползва и през производния клас.
<h3>
</h3>
